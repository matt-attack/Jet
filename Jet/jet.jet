
fun Jet::Compilation* MakeCompilation(char* project)
{
	local Jet::Compilation q;
	local c = &q;//new Jet::Compilation;
	local ctx = LLVMContextCreate();
	
	c->module = LLVMModuleCreateWithNameInContext("test", ctx);
	local voidt = LLVMVoidTypeInContext(ctx);
	
	local funtype = LLVMFunctionType(voidt, 0, 0, 0);
	
	local char* msg = 0;
	LLVMDumpType(funtype);
	local fn = LLVMAddFunction(c->module, "test", funtype);
	
	local entry = LLVMAppendBasicBlock(fn, "entry");

	local builder = LLVMCreateBuilderInContext(ctx);
	LLVMPositionBuilderAtEnd(builder, entry);
	LLVMBuildRetVoid(builder);

	LLVMPrintModuleToFile(c->module, "out.txt", &msg);
	LLVMDumpModule(c->module);
	
	
	//init stuff
	LLVMInitializeX86TargetInfo();
	LLVMInitializeX86Target();
	LLVMInitializeX86TargetMC();
	LLVMInitializeX86AsmPrinter();
	
	local char* error = 0;
	local triple = LLVMGetDefaultTargetTriple();
	local LLVMTargetRef target;
	LLVMGetTargetFromTriple(triple, &target, &error);
	
	
	local cpu = "haswell";
	local mach = LLVMCreateTargetMachine(target, triple, cpu, "",
		0/*level*/, 0/*reloc*/, 0/*codemodel*/);
	
	//local qq = LLVMGetTargetMachineData(mach);
	
	LLVMSetTarget(c->module, triple);
	//LLVMSetDataLayout(c->module, triple);//qq);
	
	LLVMTargetMachineEmitToFile(mach, c->module, "test.o", 1/*codegen*/, 0);
	
	LLVMDisposeTargetMachine(mach);

	return c;
}

namespace Jet
{
	struct Compiler
	{
		int x;
		fun void Compile(char* command)
		{
		
		}
	}
	
	struct Compilation
	{
		LLVMModuleRef module;
		
		fun void ~Compilation()
		{
			LLVMDisposeModule(this->module);
		}
	}
}

fun void main()
{
	local Jet::Compiler c;
	
	MakeCompilation("jetcore");
	
	c.Compile("jetcore");
}
