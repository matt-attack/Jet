
extern fun int printf(char* h, int h);
extern fun char* malloc(int x);

extern fun int puts(char* str);

extern fun char getchar();

/*struct function<Any T>
{
	T ptr;
	char data[64];
}

trait Any
{
}

trait IEnumerator<TT>
{
	fun TT Current();
	
	fun void Reset();
	fun bool MoveNext();
}

trait IEnumerable<T>
{
	fun IEnumerator<T> GetEnumerator();
}

fun void IEnumerable::Print()
{
	let enumer = this->GetEnumerator();
	while (enumer.MoveNext())// == 1)
	{
		puts("Got one!");
	}
}*/

fun void IEnumerator::Test()
{
	while (this->MoveNext())// == 1)
	{
		puts("testing");
        printf("Number %i\n", this->Current()); 
	}
}

generator int test(char qp)
{
	let short y = 7;
	for (let q = 10; q < 15; q++)
	{
		yield q;
	}
		
	//puts("one");
	yield y;
	//puts("two");
	yield qp;
	//puts("three");
	yield 3;
}

generator int power(int number, int exponent)
{
	let result = 1;
	for (let i = 0; i < exponent; i++)
	{
		result = result * number;
		yield result;
	}
}

/*struct WhereIterable<Any T, IEnumerable Base>
{
	Base* iterable;
	function<bool(T)> fn;
		
	fun WhereIterator<T, VectorIterator<T>> GetEnumerator()
	{
		let WhereIterator<T, VectorIterator<T>> x;
		x.iter = this->iterable->GetEnumerator();
		x.fn = this->fn;
		return x;
	}
}

struct WhereIterator<Any T, IEnumerator Base>
{
	Base iter;
	function<bool(T)> fn;
		
	fun T Current()
	{
		return this->iter.Current();
	}
		
	fun void Reset()
	{
		this->iter.Reset();
	}
		
	fun int MoveNext()
	{
		while (this->iter.MoveNext())
		{
			let fn = this->fn;
			if (fn(this->iter.Current()))
				return 1;
		}
		return 0;
	}
}*/

fun WhereIterable<T, IEnumerable> IEnumerable::Where(function<bool(T)> fn)
{
	let WhereIterable<T, IEnumerable> x;
	x.iterable = this;
	x.fn = fn;
	return x;
}

struct testv
{
  int i[20];
}

fun testv RetTest(int i)
{
  let testv t;
  return t;
}

struct qqq
{

fun testv RetTest(testv i)
{
  let testv t;
  return t;
}
}

fun int main() 
{
	/*let x = power(2, 20);
	let p = 0;
	while (x.MoveNext())
	{
		p = x.Current();
		printf("%i\n", x.Current());
	}
	if (p != 1048576)
		puts("fail");
	else
		puts("pass");
	x.Reset();
	let vector<int> tt;
	let i = 0;
   	while (x.MoveNext())
	{
		p = x.Current();
		tt.push_back(p);
		printf("Number %i\n", x.Current());
		i++;
	}
	
	if (i != tt.size())
	{
	  puts("fail");
	}
    x.Reset();
	x.Test();
	x.Test();*/
	
	//let iter = tt.GetEnumerator();
	//iter.Test();
	
	let ppx = RetTest(5);
	
	let qqq jk;
	let testv qqqq;
	let psada = jk.RetTest(qqqq);
	
	//let fn = [](int x) -> bool { return x > 4000; };
	//if (fn(5))
	//  puts("fail");
	  
	getchar();
	  
	//let where = tt.Where(fn);
    //where.Test();
		
	getchar();
	
	return 0;
}